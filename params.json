{"name":"PREP Pipeline: EEG-Clean-Tools","tagline":"Contains tools for EEG standardized preprocessing","body":"### Introduction to the PREP pipeline\r\nThe PREP pipeline is a standardized early-stage EEG processing pipeline that focuses on the identification of bad channels and the calculation of a robust average reference. PREP also has an extensive reporting facility. It is designed to be run in a completely automated way.\r\n\r\n## Requirements\r\nThe PREP pipeline relies on the MATLAB Signal Processing toolbox and EEGLAB, a freely-available MATLAB toolbox for processing EEG. EEG is available from  [http://scn.ucsd.edu/eeglab](http://scn.ucsd.edu/eeglab). PREP assumes that the EEG data is provided as an EEGLAB EEG structure and that channel locations are provided in the EEG.chanlocs structure.\r\n\r\n## Citing the PREP pipeline\r\nThe PREP pipeline is freely available under the GUN General Public License. \r\nPlease cite the following publication if using:  \r\n> Bigdely-Shamlo N, Mullen T, Kothe C, Su K-M and Robbins KA (2015)  \r\n> The PREP pipeline: standardized preprocessing for large-scale EEG analysis  \r\n> Front. Neuroinform. 9:16. doi: 10.3389/fninf.2015.00016  \r\n\r\n## Installation\r\nThe PREP pipeline can be run in two ways --- as a standalone toolbox or as an EEGLAB plugin. To run in standalone mode, simply download the PREP code, found the the EEG-Clean-Tools\r\n\r\n### PREP Overview\r\nIf you prefer to not use the automatic generator, push a branch named `gh-pages` to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.\r\n\r\n## Processing steps\r\n1.\tRemove line-noise without committing to a filtering strategy.\r\n2.\tRobustly reference the signal relative to an estimate of the “true” average reference.\r\n3.\tDetect and interpolate bad channels relative to this reference.\r\n4.\tRetain sufficient information to allow users to re-reference using another method or to undo interpolation of a particular channel.\r\n\r\n## Line noise removal\r\nWe use an interative version of the a method that estimates the amplitude and size of a deterministic sinusoid at a specified frequency embedded in locally white noise. The model is applied in sliding windows to adjust for non stationarity. The deterministic frequencies to be removed must be specified to within a small range. By default, the line noise removal (`cleanLineNoise`) attempts to removal multiples of 60 Hz. You might need to rerun with different frequencies if unusual spectral peaks are visible in the reports. \r\n\r\n# Calling sequence for line noise removal\r\nThe cleanLineNoise function takes two structures in and produces two output structures. The signal structure\r\nincludes a .data field and an .srate field. The signal structure is compatible with an EEGLAB EEG structure, but does not rely on any of the other EEGLAB fields. The data field should be channels x frames. \r\n\r\nAs with all functions in the pipeline, the algorithm parameters are passed in a structure.\r\n   [signal, lineNoiseOut] = cleanLineNoise(signal, lineNoiseIn)  \r\n   [signal, lineNoiseOut] = cleanLineNoise(signal)\r\n\r\nThe output structure contains all of the input structure fields plus additional fields containing information on the\r\ntapers used to compute the spectral components.\r\n\r\nExample:\r\n`    lineNoiseIn = struct('lineNoiseChannels', [1:32, 40:60], 'lineFrequencies', [60, 120, 180, 212, 240]);  `\r\n\r\n# Parameters for line noise removal\r\nThe following parameters appear as subfields in a structure. \r\n\r\nlineNoiseChannels \r\n   defaults = struct( ...\r\n               'lineNoiseChannels', ...\r\n                  getRules(1:size(signal.data, 1), {'numeric'}, ...\r\n                   {'row', 'positive', 'integer', '<=', size(signal.data, 1)}, ...\r\n                   'Vector of channel numbers of the channels to detrend.'), ...\r\n                'Fs', ...\r\n                   getRules(signal.srate, {'numeric'}, ...\r\n                   {'positive', 'scalar'}, ...\r\n                   'Sampling rate of the signal in Hz.'), ...\r\n                'lineFrequencies', ...\r\n                  getRules(lineFrequencies, {'numeric'}, ...\r\n                   {'row', 'positive'}, ...\r\n                   'Vector of frequencies of the line noise peaks to remove.'), ...\r\n                'p', ...\r\n                   getRules(0.01,  ...\r\n                   {'numeric'}, {'positive', 'scalar', '<', 1}, ...\r\n                   'Significance cutoff level.'),  ...\r\n                'fScanBandWidth', ...\r\n                   getRules(2,  ...\r\n                   {'numeric'}, {'positive', 'scalar'}, ...\r\n                   ['Half of the width of the frequency band centered ' ...\r\n                    'on each line frequency.']),  ...\r\n                'taperBandWidth', ...\r\n                   getRules(2,  ...\r\n                   {'numeric'}, {'positive', 'scalar'}, ...\r\n                   'Bandwidth in Hz for the tapers.'),  ...   \r\n                'taperWindowSize', ...\r\n                   getRules(4,  ...\r\n                   {'numeric'}, {'positive', 'scalar'}, ...\r\n                   'Taper sliding window length in seconds.'),  ...\r\n                 'taperWindowStep', ...\r\n                   getRules(1,  ...\r\n                   {'numeric'}, {'positive', 'scalar'}, ...\r\n                   'Taper sliding window step size in seconds. '),  ...\r\n                 'tau', ...\r\n                   getRules(100,  ...\r\n                   {'numeric'}, {'positive', 'scalar'}, ...\r\n                   'Window overlap smoothing factor.'),  ...\r\n                 'pad', ...\r\n                   getRules(0,  ...\r\n                   {'numeric'}, {'integer', 'scalar'}, ...\r\n                   ['Padding factor for FFTs (-1= no padding, 0 = pad ' ...\r\n                   'to next power of 2, 1 = pad to power of two after, etc.).']),  ...   \r\n                'fPassBand', ...\r\n                   getRules([0 signal.srate/2], {'numeric'}, ...\r\n                   {'nonnegative', 'row', 'size', [1, 2], '<=', signal.srate/2}, ...\r\n                   'Frequency band used (default [0, Fs/2])'),  ...\r\n                'maximumIterations', ...\r\n                   getRules(10,  ...\r\n                   {'numeric'}, {'positive', 'scalar'}, ...\r\n                   ['Maximum number of times the cleaning process ' ...\r\n                   'applied to remove line noise.']) ...\r\n### PREP as an EEGLAB plugin\r\nYou can install PREP as an EEGLAB plugin by unzipping the ...  \r\n\r\n## Running the PREP pipeline \r\nLoad an EEG dataset to be processed using the Load dataset submenu under the File menu of EEGLAB.  The PREP pipeline \r\ncan be found under the Tools submenu:  \r\n![PREP main menu for EEGLAB plugin](https://github.com/VisLab/EEG-Clean-Tools/blob/gh-pages/images/PrepMainMenu.png)  \r\n\r\n\r\n\r\n### Authors and Contributors\r\nYou can @mention a GitHub username to generate a link to their profile. The resulting `<a>` element will link to the contributor’s GitHub Profile. For example: In 2007, Chris Wanstrath (@defunkt), PJ Hyett (@pjhyett), and Tom Preston-Werner (@mojombo) founded GitHub.\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out our [documentation](https://help.github.com/pages) or [contact support](https://github.com/contact) and we’ll help you sort it out.\r\n","google":"UA-66346771-1","note":"Don't delete this file! It's used internally to help with page regeneration."}